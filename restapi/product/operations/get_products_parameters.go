// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"net/http"

	"github.com/ckpbin/response"
	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
	"github.com/labstack/echo/v4"
)

// GetProductsEndpoint executes the core logic of the related
// route endpoint.
func GetProductsEndpoint(handler func(c echo.Context, params *GetProductsParams) *response.Response) echo.HandlerFunc {
	return func(c echo.Context) error {
		// generate params from request
		params := NewGetProductsParams()
		problem := response.Problem{}
		if err := params.readRequest(c); err != nil {
			switch e := err.(type) {
			case *errors.CompositeError:
				problem = response.Problem{
					Title:  http.StatusText(int(e.Code())),
					Status: int(e.Code()),
					Detail: response.FormatErrors(e),
				}
			default:
				problem = response.Problem{
					Title:  http.StatusText(http.StatusBadRequest),
					Status: http.StatusBadRequest,
					Detail: "Unrecognized http error",
				}
			}

			return c.JSON(problem.Status, problem)
		}

		resp := handler(c, params)

		switch resp.Code {
		case http.StatusNoContent:
			return c.JSON(resp.Code, nil)
		default:
			return c.JSON(resp.Code, resp.Body)
		}
	}
}

// NewGetProductsParams creates a new GetProductsParams object
// with the default values initialized.
func NewGetProductsParams() *GetProductsParams {
	var (
		limitDefault  = int64(20)
		offsetDefault = int64(0)
	)
	return &GetProductsParams{
		Limit: &limitDefault,

		Offset: &offsetDefault,
	}
}

// GetProductsParams contains all the bound params for the get products operation
// typically these are obtained from a http.Request
//
// swagger:parameters getProducts
type GetProductsParams struct {

	/*
	  Maximum: 50
	  Minimum: 10
	  In: query
	  Default: 20
	*/
	Limit *int64
	/*
	  Minimum: 0
	  In: query
	  Default: 0
	*/
	Offset *int64
	/*
	  In: query
	*/
	OrderBy []string
	/*
	  In: query
	*/
	PrevPage []string
}

// readRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls
func (o *GetProductsParams) readRequest(ctx echo.Context) error {
	var res []error
	formats := strfmt.NewFormats()

	qs := runtime.Values(ctx.Request().URL.Query())

	qLimit, qhkLimit, _ := qs.GetOK("limit")
	if err := o.bindLimit(qLimit, qhkLimit, formats); err != nil {
		res = append(res, err)
	}

	qOffset, qhkOffset, _ := qs.GetOK("offset")
	if err := o.bindOffset(qOffset, qhkOffset, formats); err != nil {
		res = append(res, err)
	}

	qOrderBy, qhkOrderBy, _ := qs.GetOK("order_by")
	if err := o.bindOrderBy(qOrderBy, qhkOrderBy, formats); err != nil {
		res = append(res, err)
	}

	qPrevPage, qhkPrevPage, _ := qs.GetOK("prev_page")
	if err := o.bindPrevPage(qPrevPage, qhkPrevPage, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetProductsParams) bindLimit(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}
	if raw == "" { // empty values pass all other validations
		var limitDefault int64 = int64(20)
		o.Limit = &limitDefault
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("limit", "query", "int64", raw)
	}
	o.Limit = &value

	if err := o.validateLimit(formats); err != nil {
		return err
	}

	return nil
}

func (o *GetProductsParams) validateLimit(formats strfmt.Registry) error {

	if err := validate.MinimumInt("limit", "query", int64(*o.Limit), 10, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("limit", "query", int64(*o.Limit), 50, false); err != nil {
		return err
	}

	return nil
}

func (o *GetProductsParams) bindOffset(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}
	if raw == "" { // empty values pass all other validations
		var offsetDefault int64 = int64(0)
		o.Offset = &offsetDefault
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("offset", "query", "int64", raw)
	}
	o.Offset = &value

	if err := o.validateOffset(formats); err != nil {
		return err
	}

	return nil
}

func (o *GetProductsParams) validateOffset(formats strfmt.Registry) error {

	if err := validate.MinimumInt("offset", "query", int64(*o.Offset), 0, false); err != nil {
		return err
	}

	return nil
}

func (o *GetProductsParams) bindOrderBy(rawData []string, hasKey bool, formats strfmt.Registry) error {

	var qvOrderBy string
	if len(rawData) > 0 {
		qvOrderBy = rawData[len(rawData)-1]
	}

	orderByIC := swag.SplitByFormat(qvOrderBy, "")

	if len(orderByIC) == 0 {
		return nil
	}

	var orderByIR []string
	for _, orderByIV := range orderByIC {
		orderByI := orderByIV

		orderByIR = append(orderByIR, orderByI)
	}

	o.OrderBy = orderByIR

	return nil
}

func (o *GetProductsParams) bindPrevPage(rawData []string, hasKey bool, formats strfmt.Registry) error {

	var qvPrevPage string
	if len(rawData) > 0 {
		qvPrevPage = rawData[len(rawData)-1]
	}

	prevPageIC := swag.SplitByFormat(qvPrevPage, "")

	if len(prevPageIC) == 0 {
		return nil
	}

	var prevPageIR []string
	for _, prevPageIV := range prevPageIC {
		prevPageI := prevPageIV

		prevPageIR = append(prevPageIR, prevPageI)
	}

	o.PrevPage = prevPageIR

	return nil
}

// vim: ft=go
